REACT
=>our chrome browser wont understand the jsx so babel converst the jsx to normal vanila javascript code which our chrome browser will undersatnd

states
it allow us manage and isplay changing data in our application
state is used to tell react to watch this variable and if any changes then reflect  on the DOM

Hookes
are funntction to use some react features in functional compoenents
are the the functions that makes functional components work like class functions
=================================================================================================
useState hook
is a function to add state in functional component
whenever u want to use variable u can use useState hook
======================================================================================================
useEffect 
What is useEffect?

In simple words:
useEffect is used to perform â€œside effectsâ€ in a React component.

â“ What are side effects?
Anything that is not directly UI rendering.

Examples:
Fetching data from an API
Updating the browser title
Setting a timer (setTimeout, setInterval)
Subscribing/unsubscribing to something
Accessing DOM
Calling setState after render
ğŸ‘‰ Rendering = showing UI
ğŸ‘‰ Side effect = doing extra work after UI is shown

ğŸ”¹ Why does React need useEffect?

React works like this:
Component renders UI
React updates the DOM
Then side effects should run

If React allowed side effects directly inside render:
Infinite loops
Unpredictable UI
Performance issues

So React says:
â€œFirst render UI.
Then Iâ€™ll give you useEffect to run side effects safely.â€

Every time state changes, React does this:
Re-runs the entire component function
Recalculates JSX
Updates the DOM if needed
Then runs useEffect 
===================================================================================================
cleanups with useefffect
Whenever count changes, stop the old timer that knows the old count, and start a new timer that knows the new count.
=============================================================================================
useContext
What is useContext? (In simple words)

useContext is a React hook used to share data globally between components without passing props manually at every level.
It solves the problem called props drilling.

========================================================================================
What are Props? 

Props (properties) are how a parent component sends data to a child component.
Think of props as:
ğŸ‘‰ function parameters, but for components.

ğŸ”¹ Basic Rule of Props (VERY IMPORTANT)
Data flows from parent â†’ child only
(One-way data flow)
Child âŒ cannot change props directly

Complete Example (Simple & Clear)
ğŸ“ App.jsx (Parent)
function App() {
  return <Student name="Meghana" branch="CSE" />;
}

ğŸ“ Student.jsx (Child)
function Student({ name, branch }) {
  return <p>{name} studies {branch}</p>;

==================================================================================================
useRef-
=>create a mutable variable without causing rerender
=>accesing the DOM element
===============================================================================================
useReducer
=>it is used to mangae state in our react application
=>it works like a state management tool
=>state managemnt is used to manage  all states of application in a simple way
=>always use this useRweducer hooks when u have a lot of states and methods to handle

ğŸ” React Render & Effect Flow (FULL PICTURE)

Weâ€™ll use this component as reference:

function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("useEffect runs");
  }, []);

  return <h1>{count}</h1>;
}

1ï¸âƒ£ STEP 1: React calls the component (Render Phase)

ğŸ‘‰ React calls App() function

What happens here:
useState values are read
JSX is calculated
NO DOM update yet
NO useEffect yet
ğŸ“Œ This phase is called Render Phase

2ï¸âƒ£ STEP 2: JSX â†’ Virtual DOM

React:
Converts JSX to Virtual DOM
Compares with previous Virtual DOM (diffing)
Finds what changed
ğŸ§  Still nothing shown on screen

3ï¸âƒ£ STEP 3: Commit Phase (UI updates)

Now React:
Updates real DOM
Browser paints the UI
User can see UI

ğŸ“Œ This is when:
âœ” Text
âœ” Buttons
âœ” Inputs
âœ” UI layout
ğŸ‘‰ UI IS NOW RENDERED

4ï¸âƒ£ STEP 4: useEffect runs (AFTER UI paint)
Now and ONLY NOW:

useEffect(() => {
  console.log("runs after UI");
}, []);

ğŸŸ¢ useEffect always runs AFTER UI is visible
ğŸ“Œ This is why:

API calls go in useEffect
DOM access goes in useEffect
Timers go in useEffect

5ï¸âƒ£ ORDER (VERY IMPORTANT)
âœ… Actual order:
1. Component function runs
2. JSX created
3. UI painted on screen
4. useEffect executes
ğŸ’¡ useEffect NEVER blocks UI rendering

6ï¸âƒ£ When does re-render happen?

Re-render happens when:
setState() is called
props change
parent re-renders
Example:
setCount(count + 1);

7ï¸âƒ£ Re-render flow (FULL LOOP)

When state changes:
setState()
â†“
Component function runs again
â†“
JSX recalculated
â†“
DOM updated (only changes)
â†“
UI re-painted
â†“
useEffect runs again (if dependencies match)

8ï¸âƒ£ Dependency array controls useEffect
| Dependency | When effect runs        |
| ---------- | ----------------------- |
| No array   | After EVERY render      |
| `[]`       | After FIRST render only |
| `[count]`  | When `count` changes    |


9ï¸âƒ£ Cleanup function timing
useEffect(() => {
  console.log("effect");

  return () => {
    console.log("cleanup");
  };
}, [count]);

Execution order:
First render:
UI renders
effect runs

count changes:
cleanup runs (old effect)
UI re-renders
effect runs again

Component unmount:
cleanup runs

ğŸ”Ÿ Where useRef fits in lifecycle
const ref = useRef(0);
Value persists across renders

Changing ref.current:
âŒ does NOT re-render

Used for:
previous values
DOM reference
render count
timers

1ï¸âƒ£1ï¸âƒ£ Full lifecycle diagram (remember this)
Render Phase
â†“
Virtual DOM diff
â†“
Commit Phase (UI shown)
â†“
useEffect runs
â†“
(setState?) â†’ Re-render

1ï¸âƒ£2ï¸âƒ£ Interview-ready ONE LINE
React first renders the UI, then runs useEffect. Any state update causes a re-render, and useEffect runs again based on its dependencies.

1ï¸âƒ£3ï¸âƒ£ When NOT to use useEffect
âŒ Calculations
âŒ UI logic
âŒ Simple derived values
âœ” UseEffect is for:
side effects
API calls
subscriptions
timers
