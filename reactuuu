REACT
=>our chrome browser wont understand the jsx so babel converst the jsx to normal vanila javascript code which our chrome browser will undersatnd

states
it allow us manage and isplay changing data in our application
state is used to tell react to watch this variable and if any changes then reflect  on the DOM

Hookes
are funntction to use some react features in functional compoenents
are the the functions that makes functional components work like class functions
=================================================================================================
useState hook
is a function to add state in functional component
whenever u want to use variable u can use useState hook
======================================================================================================
useEffect 
What is useEffect?

In simple words:
useEffect is used to perform â€œside effectsâ€ in a React component.

â“ What are side effects?
Anything that is not directly UI rendering.

Examples:
Fetching data from an API
Updating the browser title
Setting a timer (setTimeout, setInterval)
Subscribing/unsubscribing to something
Accessing DOM
Calling setState after render
ğŸ‘‰ Rendering = showing UI
ğŸ‘‰ Side effect = doing extra work after UI is shown

ğŸ”¹ Why does React need useEffect?

React works like this:
Component renders UI
React updates the DOM
Then side effects should run

If React allowed side effects directly inside render:
Infinite loops
Unpredictable UI
Performance issues

So React says:
â€œFirst render UI.
Then Iâ€™ll give you useEffect to run side effects safely.â€

Every time state changes, React does this:
Re-runs the entire component function
Recalculates JSX
Updates the DOM if needed
Then runs useEffect 
===================================================================================================
cleanups with useefffect
Whenever count changes, stop the old timer that knows the old count, and start a new timer that knows the new count.
=============================================================================================
useContext
What is useContext? (In simple words)

useContext is a React hook used to share data globally between components without passing props manually at every level.
It solves the problem called props drilling.

========================================================================================
What are Props? 

Props (properties) are how a parent component sends data to a child component.
Think of props as:
ğŸ‘‰ function parameters, but for components.

ğŸ”¹ Basic Rule of Props (VERY IMPORTANT)
Data flows from parent â†’ child only
(One-way data flow)
Child âŒ cannot change props directly

Complete Example (Simple & Clear)
ğŸ“ App.jsx (Parent)
function App() {
  return <Student name="Meghana" branch="CSE" />;
}

ğŸ“ Student.jsx (Child)
function Student({ name, branch }) {
  return <p>{name} studies {branch}</p>;

==================================================================================================
useRef-
=>create a mutable variable without causing rerender
=>accesing the DOM element

import React, { useRef } from 'react'
const App = () => {

  const inputEle=useRef();
  
  function handleInput(){
      console.log(inputEle.current);
      inputEle.current.style.width='300px';
      inputEle.current.style.height='90px';
      inputEle.current.focus();
  }
 return (
    <>
    <input type='text' ref={inputEle} />
    <button onClick={handleInput}>click me</button>
    </>
  )
}
export default App
===============================================================================================
useReducer
=>it is used to mangae state in our react application
=>it works like a state management tool
=>state managemnt is used to manage  all states of application in a simple way
=>always use this useRweducer hooks when u have a lot of states and methods to handle

1. The Bank Vault (initialState)
Before the bank opens, the vault has a specific amount of money.
State: { balance: 500 }.
This is the starting

2. The Customer (The UI / Component)
You are the customer standing at the window. You see your current balance on a screen.
You decide you want to add money.

3. The Deposit Slip (The Dispatch & Action)
You fill out a slip. This slip is your Action.
It has a type: "DEPOSIT".
It has a payload: 100 (the amount).
You hand this slip to the teller. Handing it over is the dispatch.

4. The Bank Teller (The Reducer)
The teller is the Reducer. The teller is the only one allowed to calculate new totals.
The teller looks at the Current Balance in the vault ($500).
The teller looks at your Slip (Deposit $100).
The teller does the math: $500 + 100 = 600$.

5. The New Statement (The Return/New State)
The teller does not cross out the old number. Instead, the teller prints a brand new bank statement: { balance: 600 }.
This must be an object because a bank account is a "record" (a row), and records have structure.
React takes this new statement and updates your screen.

  import React,{useReducer}from 'react'
  const initialState={count:0};
  function reducer(state,action)
  {
    switch(action.type){
      case "INCREAMENT":
        return {count:state.count+1};
      case "DECREAMENT":
        return {count:state.count-1};
      default:
        return state;
    }

  }
  const App = () => {
  const [state,dispatch]=useReducer(reducer,initialState);
    return (
      <>
      <h1>{state.count}</h1>
      <div>hello react world</div>
      <button onClick={()=>dispatch({type:"INCREAMENT"})}>increase</button>
      <button onClick={()=>dispatch({type:"DECREAMENT"})}>decrease</button>
      </>
    )
  }

  export default App;


============================================================================================================
USELAYOUTEFFECT(its synchronous line by line)
To understand useLayoutEffect, you first need to know its famous brother: useEffect. They look almost identical, 
but the timing of when they run is the only difference.

1. The Timing: Why it matters
When React updates your screen, it follows a specific order:
Render: React calculates what the UI should look like (the App function runs).
Commit: React changes the actual DOM (the hidden structure of the webpage).
Browser Paint: The browser physically draws the pixels on your monitor so you can see them.

useEffect (The standard choice)
Runs AFTER the Browser Paint. The user sees the screen update first, then your code runs in the background. This is good for 99% of tasks (like fetching data).
useLayoutEffect (The special choice)
Runs BEFORE the Browser Paint, but after React has changed the DOM. This means the browser is "paused"â€”it waits for your code
to finish before it shows the screen to the user.

2. When do you actually use it?
You use useLayoutEffect to prevent "Flickering."
Imagine you want to measure the width of a div and move a button based on that width:
With useEffect: The user sees the button in the wrong place for a split second, then it "jumps" to the right place.
With useLayoutEffect: The user never sees the wrong position. React measures and moves the button before the screen ever flashes.

 import React,{useEffect,useLayoutEffect,useRef, useReducer,useState}from 'react'
  const initialState={count:0};
  
  function reducer(state,action)
  {
    switch(action.type){
      case "INCREAMENT":
        return {count:state.count+1};
      case "DECREAMENT":
        return {count:state.count-1};
      default:
        return state;
    }

  }
  const App = () => {
    const [toggle,setToggle]=useState(false);
const textRef=useRef();
  useLayoutEffect(()=>{
    if(textRef.current!=null)
    {
      const dimension=textRef.current.getBoundingClientRect();
      textRef.current.style.paddingTop=`${dimension.height}px`
      console.log("meowmewo");
    }
  },[toggle])

    useLayoutEffect(()=>{
    console.log("uselayouteffect")
  },[toggle])
  
     useEffect(()=>{
    console.log("usefct")
  },[toggle])
  const [state,dispatch]=useReducer(reducer,initialState);
    return (
      <>
      <h1>{state.count}</h1>
      <div>hello react world</div>
      <button onClick={()=>setToggle(!toggle)}>toggle</button>
      <button onClick={()=>dispatch({type:"INCREAMENT"})}>increase</button>
     
      <button onClick={()=>dispatch({type:"DECREAMENT"})}>decrease</button>
     {toggle&&<h4 ref={textRef}>code bless you</h4>}
     
      </>
    )
  }

  export default App;


==============================================================================================================
USEMEMO 
In React, "Memo" stands for Memoization, which basically means "remembering" a value so you don't have to calculate it again.

1. The Problem: Expensive Calculations
Imagine your App function runs every time you click "Toggle." If you have a piece 
of code that takes along time to run (like sorting a list of 10,000 items),React will 
run that slow code every single time you toggle, even if the list hasn't changed! This
makes your app laggy.
2. The Solution: useMemo
useMemo tells React: "Only run this math logic if a specific variable has changed.
Otherwise, just give me the answer you remembered from last time."


useMemo vs useEffect
This is where people get confused. Here is the simple rule:
useEffect: Use this when you want to DO something (like change the DOM, log to console, or fetch data). It doesn't return a value to your component.
useMemo: Use this when you want to GET a value. It returns the result of the function directly to a variable.
================================================================================================================
USECALLBACK
useMemo vs useCallback
This is the most common confusion. Here is the simple distinction:
useMemo: Remembers the result of a function (a number, a string, an object).
useCallback: Remembers the function itself.
========================================================================================================
CUSTOMHOOKS

A Custom Hook is simply a JavaScript function whose name starts with "use" and that can call other Hooks. 
It allows you to extract component logic into reusable functions so you donâ€™t have to copy-paste the same code in multiple places.

import React from 'react'
import useFetch from './costomHook/useFetch'

const App = () => {
const data=useFetch('https://jsonplaceholder.typicode.com/users')
  return (
    <>
      {data.map((res)=>{
      return(
        <h1 key={res.id}>
          {res.id}.{res.name}
        </h1>
      )
    })}</>
  
  )
}

export default App
----------------------------------------------------------
costomhook/useFetch
import React,{useEffect,useState} from 'react'

const useFetch = (url) => {
      const [response,setResponse]=useState([]);
      useEffect(()=>{
        fetch(url)
        .then((res)=>res.json())
        .then((data)=>setResponse(data))
      },[])
  return response;
}

export default useFetch









======================================================================================================
REACT BASIC STRUCTURE RULES

1. The "Basics" Rule: Outside vs. Inside
Outside the Function (The "Static" Zone)
Anything you put here is created only once when your app first starts. It never changes, and it doesn't "re-run."
What goes here? Your initialState and your reducer function.
Why? Because the logic of how to add 1 + 1 (the reducer) doesn't change, and your starting point (initialState) is a constant.
If you put them inside, React wastes time re-creating them every single time you click a button.

Inside the Function (The "Re-render" Zone)
This is the area between const App = () => { and return (...). Everything in this zone runs again every time the state changes.
What goes here? Hooks like useReducer or useState.
Why? Because React needs to "check in" with these hooks every time it re-renders to see what the current value is.

2. What exactly is "Re-rendering"?
Re-rendering is just React re-calling your function to see if the UI (the HTML) needs to change.
Initial Render: React runs your App function. It sees count: 0. It draws <h1>0</h1> on the screen.
The Trigger: You click the "Increase" button. This calls dispatch.
The Logic: React sends the current state and your action to the reducer. The reducer returns {count: 1}.
The Re-render: React says, "Oh! The state is different now!" It runs the App function again from the top.
The Update: This time, when it hits <h1>{state.count}</h1>, it sees 1. It updates the screen.

RETURN holds the UI part 
---------------------------------------------------------------
ğŸ” React Render & Effect Flow (FULL PICTURE)
Weâ€™ll use this component as reference:

function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("useEffect runs");
  }, []);

  return <h1>{count}</h1>;
}

1ï¸âƒ£ STEP 1: React calls the component (Render Phase)

ğŸ‘‰ React calls App() function

What happens here:
useState values are read
JSX is calculated
NO DOM update yet
NO useEffect yet
ğŸ“Œ This phase is called Render Phase

2ï¸âƒ£ STEP 2: JSX â†’ Virtual DOM

React:
Converts JSX to Virtual DOM
Compares with previous Virtual DOM (diffing)
Finds what changed
ğŸ§  Still nothing shown on screen

3ï¸âƒ£ STEP 3: Commit Phase (UI updates)

Now React:
Updates real DOM
Browser paints the UI
User can see UI

ğŸ“Œ This is when:
âœ” Text
âœ” Buttons
âœ” Inputs
âœ” UI layout
ğŸ‘‰ UI IS NOW RENDERED

4ï¸âƒ£ STEP 4: useEffect runs (AFTER UI paint)
Now and ONLY NOW:

useEffect(() => {
  console.log("runs after UI");
}, []);

ğŸŸ¢ useEffect always runs AFTER UI is visible
ğŸ“Œ This is why:

API calls go in useEffect
DOM access goes in useEffect
Timers go in useEffect

5ï¸âƒ£ ORDER (VERY IMPORTANT)
âœ… Actual order:
1. Component function runs
2. JSX created
3. UI painted on screen
4. useEffect executes
ğŸ’¡ useEffect NEVER blocks UI rendering

6ï¸âƒ£ When does re-render happen?

Re-render happens when:
setState() is called
props change
parent re-renders
Example:
setCount(count + 1);

7ï¸âƒ£ Re-render flow (FULL LOOP)

When state changes:
setState()
â†“
Component function runs again
â†“
JSX recalculated
â†“
DOM updated (only changes)
â†“
UI re-painted
â†“
useEffect runs again (if dependencies match)

8ï¸âƒ£ Dependency array controls useEffect
| Dependency | When effect runs        |
| ---------- | ----------------------- |
| No array   | After EVERY render      |
| `[]`       | After FIRST render only |
| `[count]`  | When `count` changes    |


9ï¸âƒ£ Cleanup function timing
useEffect(() => {
  console.log("effect");

  return () => {
    console.log("cleanup");
  };
}, [count]);

Execution order:
First render:
UI renders
effect runs

count changes:
cleanup runs (old effect)
UI re-renders
effect runs again

Component unmount:
cleanup runs

ğŸ”Ÿ Where useRef fits in lifecycle
const ref = useRef(0);
Value persists across renders

Changing ref.current:
âŒ does NOT re-render

Used for:
previous values
DOM reference
render count
timers

1ï¸âƒ£1ï¸âƒ£ Full lifecycle diagram (remember this)
Render Phase
â†“
Virtual DOM diff
â†“
Commit Phase (UI shown)
â†“
useEffect runs
â†“
(setState?) â†’ Re-render

1ï¸âƒ£2ï¸âƒ£ Interview-ready ONE LINE
React first renders the UI, then runs useEffect. Any state update causes a re-render, and useEffect runs again based on its dependencies.

1ï¸âƒ£3ï¸âƒ£ When NOT to use useEffect
âŒ Calculations
âŒ UI logic
âŒ Simple derived values
âœ” UseEffect is for:
side effects
API calls
subscriptions
timers
